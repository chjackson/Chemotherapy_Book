method = "mm",
model_fn = calculate_costs_effects,
analysis_args = list(a1 = beta_params_t1[1],
b1 = beta_params_t1[2],
a2 = beta_params_t2$alpha,
b2 = beta_params_t2$beta),
par_fn = generate_psa_parameters)
debug(evsi)
evsi_default <- evsi(outputs = chemotherapy_output,
inputs = m_params,
study = "trial_binary",
pars = c("p_side_effects_t1", "p_side_effects_t2"),
n = seq(500, 1500, by = 20),
method = "mm",
model_fn = calculate_costs_effects,
analysis_args = list(a1 = beta_params_t1[1],
b1 = beta_params_t1[2],
a2 = beta_params_t2$alpha,
b2 = beta_params_t2$beta),
par_fn = generate_psa_parameters)
debug(evsi_mm)
debug(evsi_mm_cea)
debug(evsi_mm_core)
undebug(evsi_mm_core)
undebug(evsi_mm)
underbug(evsi_mm_cea())
underbug(evsi_mm_cea
)
undebug(evsi_mm_cea)
undebug(evsi)
### HAD TO LEAVE OUT THE n ARGS - NEED TO BE ABLE TO HAVE n IN CHECK_ANALYSIS_FUN.
OR_analysis_fn <- function(data, args, pars){
X1 <- data$X1
X2 <- data$X2
data_jags <- list(X1 = X1,
X2 = X2,
n = args$n,
n_side_effects = args$n_side_effects,
n_patients = args$n_patients,
logor_side_effects_mu = args$logor_side_effects_mu,
logor_side_effects_sd = args$logor_side_effects_sd)
LogOR_trial <- function(){
# Probability of side effects under treatment 1
p_side_effects_t1 ~ dbeta(1 + n_side_effects,
1 + n_patients - n_side_effects)
# Log odds of side effects on treatment 2
logor_side_effects ~ dnorm(logor_side_effects_mu, logor_side_effects_sd)
# Odds of side effects on treatment 1
odds_side_effects_t1 <- p_side_effects_t1 / (1 - p_side_effects_t1)
# Odds for side effects on treatment 2
odds_side_effects_t2 <- odds_side_effects_t1 * exp(logor_side_effects)
# Probability of side effects under treatment 2
p_side_effects_t2    <- odds_side_effects_t2 / (1 + odds_side_effects_t2)
X1 ~ dbin(p_side_effects_t1, n)
X2 ~ dbin(p_side_effects_t2, n)
}
filein <- file.path(tempdir(),fileext="datmodel.txt")
R2OpenBUGS::write.model(LogOR_trial,filein)
# Perform the MCMC simulation with OpenBUGS.
# Close OpenBUGS once it has finished (if debug is set to TRUE)
bugs.data <- jags(
data =  data_jags,
parameters.to.save = pars,
model.file = filein,
n.chains = 3,
n.iter = args$n.iter,
n.thin = 1,
n.burnin = 250, progress.bar = "none")
resample_t1 <- rbeta(length(bugs.data$BUGSoutput$sims.matrix[, pars[2]]),
1 + args$n_side_effects,
1 + args$n_patients - args$n_side_effects)
return(data.frame(p_side_effects_t1 = resample_t1,
p_side_effects_t2 = bugs.data$BUGSoutput$sims.matrix[, pars[2]]))
}
evsi_OR <- evsi(outputs = chemotherapy_output,
inputs = m_params,
pars = c("p_side_effects_t1", "p_side_effects_t2"),
n = seq(500, 1500, by = 20),
method = "mm",
datagen_fn = OR_datagen_fn,
model_fn = calculate_costs_effects,
analysis_args = list(n = 500,
n_side_effects = n_side_effects,
n_patients = n_patients,
logor_side_effects_mu = logor_side_effects_mu,
logor_side_effects_sd = logor_side_effects_sd,
n.iter = 5000),
analysis_fn = OR_analysis_fn,
par_fn = generate_psa_parameters)
### Written Out ###
OR_datagen_fn <- function(inputs, n = 500){
p_side_effects_t1 <- inputs[, "p_side_effects_t1"]
p_side_effects_t2 <- inputs[, "p_side_effects_t2"]
X1 <- rbinom(length(p_side_effects_t1), n, p_side_effects_t1)
X2 <- rbinom(length(p_side_effects_t2), n, p_side_effects_t2)
data_save <- data.frame(X1 = X1, X2 = X2)
return(data_save)
}
### HAD TO LEAVE OUT THE n ARGS - NEED TO BE ABLE TO HAVE n IN CHECK_ANALYSIS_FUN.
OR_analysis_fn <- function(data, args, pars){
X1 <- data$X1
X2 <- data$X2
data_jags <- list(X1 = X1,
X2 = X2,
n = args$n,
n_side_effects = args$n_side_effects,
n_patients = args$n_patients,
logor_side_effects_mu = args$logor_side_effects_mu,
logor_side_effects_sd = args$logor_side_effects_sd)
LogOR_trial <- function(){
# Probability of side effects under treatment 1
p_side_effects_t1 ~ dbeta(1 + n_side_effects,
1 + n_patients - n_side_effects)
# Log odds of side effects on treatment 2
logor_side_effects ~ dnorm(logor_side_effects_mu, logor_side_effects_sd)
# Odds of side effects on treatment 1
odds_side_effects_t1 <- p_side_effects_t1 / (1 - p_side_effects_t1)
# Odds for side effects on treatment 2
odds_side_effects_t2 <- odds_side_effects_t1 * exp(logor_side_effects)
# Probability of side effects under treatment 2
p_side_effects_t2    <- odds_side_effects_t2 / (1 + odds_side_effects_t2)
X1 ~ dbin(p_side_effects_t1, n)
X2 ~ dbin(p_side_effects_t2, n)
}
filein <- file.path(tempdir(),fileext="datmodel.txt")
R2OpenBUGS::write.model(LogOR_trial,filein)
# Perform the MCMC simulation with OpenBUGS.
# Close OpenBUGS once it has finished (if debug is set to TRUE)
bugs.data <- jags(
data =  data_jags,
parameters.to.save = pars,
model.file = filein,
n.chains = 3,
n.iter = args$n.iter,
n.thin = 1,
n.burnin = 250, progress.bar = "none")
resample_t1 <- rbeta(length(bugs.data$BUGSoutput$sims.matrix[, pars[2]]),
1 + args$n_side_effects,
1 + args$n_patients - args$n_side_effects)
return(data.frame(p_side_effects_t1 = resample_t1,
p_side_effects_t2 = bugs.data$BUGSoutput$sims.matrix[, pars[2]]))
}
evsi_OR <- evsi(outputs = chemotherapy_output,
inputs = m_params,
pars = c("p_side_effects_t1", "p_side_effects_t2"),
n = seq(500, 1500, by = 20),
method = "mm",
datagen_fn = OR_datagen_fn,
model_fn = calculate_costs_effects,
analysis_args = list(n = 500,
n_side_effects = n_side_effects,
n_patients = n_patients,
logor_side_effects_mu = logor_side_effects_mu,
logor_side_effects_sd = logor_side_effects_sd,
n.iter = 5000),
analysis_fn = OR_analysis_fn,
par_fn = generate_psa_parameters)
evsi_OR <- evsi(outputs = chemotherapy_output,
inputs = m_params,
pars = c("p_side_effects_t1", "p_side_effects_t2"),
n = seq(500, 1500, by = 20),
method = "mm",
datagen_fn = OR_datagen_fn,
model_fn = calculate_costs_effects,
analysis_args = list(n_side_effects = n_side_effects,
n_patients = n_patients,
logor_side_effects_mu = logor_side_effects_mu,
logor_side_effects_sd = logor_side_effects_sd,
n.iter = 5000),
analysis_fn = OR_analysis_fn,
par_fn = generate_psa_parameters)
X1 <- data$X1
### HAD TO LEAVE OUT THE n ARGS - NEED TO BE ABLE TO HAVE n IN CHECK_ANALYSIS_FUN.
OR_analysis_fn <- function(data, args, pars){
X1 <- data$X1
X2 <- data$X2
data_jags <- list(X1 = X1,
X2 = X2,
n = args$n_data,
n_side_effects = args$n_side_effects,
n_patients = args$n_patients,
logor_side_effects_mu = args$logor_side_effects_mu,
logor_side_effects_sd = args$logor_side_effects_sd)
LogOR_trial <- function(){
# Probability of side effects under treatment 1
p_side_effects_t1 ~ dbeta(1 + n_side_effects,
1 + n_patients - n_side_effects)
# Log odds of side effects on treatment 2
logor_side_effects ~ dnorm(logor_side_effects_mu, logor_side_effects_sd)
# Odds of side effects on treatment 1
odds_side_effects_t1 <- p_side_effects_t1 / (1 - p_side_effects_t1)
# Odds for side effects on treatment 2
odds_side_effects_t2 <- odds_side_effects_t1 * exp(logor_side_effects)
# Probability of side effects under treatment 2
p_side_effects_t2    <- odds_side_effects_t2 / (1 + odds_side_effects_t2)
X1 ~ dbin(p_side_effects_t1, n)
X2 ~ dbin(p_side_effects_t2, n)
}
filein <- file.path(tempdir(),fileext="datmodel.txt")
R2OpenBUGS::write.model(LogOR_trial,filein)
# Perform the MCMC simulation with OpenBUGS.
# Close OpenBUGS once it has finished (if debug is set to TRUE)
bugs.data <- jags(
data =  data_jags,
parameters.to.save = pars,
model.file = filein,
n.chains = 3,
n.iter = args$n.iter,
n.thin = 1,
n.burnin = 250, progress.bar = "none")
resample_t1 <- rbeta(length(bugs.data$BUGSoutput$sims.matrix[, pars[2]]),
1 + args$n_side_effects,
1 + args$n_patients - args$n_side_effects)
return(data.frame(p_side_effects_t1 = resample_t1,
p_side_effects_t2 = bugs.data$BUGSoutput$sims.matrix[, pars[2]]))
}
evsi_OR <- evsi(outputs = chemotherapy_output,
inputs = m_params,
pars = c("p_side_effects_t1", "p_side_effects_t2"),
n = seq(500, 1500, by = 20),
method = "mm",
datagen_fn = OR_datagen_fn,
model_fn = calculate_costs_effects,
analysis_args = list(n_side_effects = n_side_effects,
n_patients = n_patients,
logor_side_effects_mu = logor_side_effects_mu,
logor_side_effects_sd = logor_side_effects_sd,
n.iter = 5000),
analysis_fn = OR_analysis_fn,
par_fn = generate_psa_parameters)
### HAD TO LEAVE OUT THE n ARGS - NEED TO BE ABLE TO HAVE n IN CHECK_ANALYSIS_FUN.
OR_analysis_fn <- function(data, args, pars){
X1 <- data$X1
X2 <- data$X2
data_jags <- list(X1 = X1,
X2 = X2,
n = args$n,
n_side_effects = args$n_side_effects,
n_patients = args$n_patients,
logor_side_effects_mu = args$logor_side_effects_mu,
logor_side_effects_sd = args$logor_side_effects_sd)
LogOR_trial <- function(){
# Probability of side effects under treatment 1
p_side_effects_t1 ~ dbeta(1 + n_side_effects,
1 + n_patients - n_side_effects)
# Log odds of side effects on treatment 2
logor_side_effects ~ dnorm(logor_side_effects_mu, logor_side_effects_sd)
# Odds of side effects on treatment 1
odds_side_effects_t1 <- p_side_effects_t1 / (1 - p_side_effects_t1)
# Odds for side effects on treatment 2
odds_side_effects_t2 <- odds_side_effects_t1 * exp(logor_side_effects)
# Probability of side effects under treatment 2
p_side_effects_t2    <- odds_side_effects_t2 / (1 + odds_side_effects_t2)
X1 ~ dbin(p_side_effects_t1, n)
X2 ~ dbin(p_side_effects_t2, n)
}
filein <- file.path(tempdir(),fileext="datmodel.txt")
R2OpenBUGS::write.model(LogOR_trial,filein)
# Perform the MCMC simulation with OpenBUGS.
# Close OpenBUGS once it has finished (if debug is set to TRUE)
bugs.data <- jags(
data =  data_jags,
parameters.to.save = pars,
model.file = filein,
n.chains = 3,
n.iter = args$n.iter,
n.thin = 1,
n.burnin = 250, progress.bar = "none")
resample_t1 <- rbeta(length(bugs.data$BUGSoutput$sims.matrix[, pars[2]]),
1 + args$n_side_effects,
1 + args$n_patients - args$n_side_effects)
return(data.frame(p_side_effects_t1 = resample_t1,
p_side_effects_t2 = bugs.data$BUGSoutput$sims.matrix[, pars[2]]))
}
evsi_OR <- evsi(outputs = chemotherapy_output,
inputs = m_params,
pars = c("p_side_effects_t1", "p_side_effects_t2"),
n = seq(500, 1500, by = 20),
method = "mm",
datagen_fn = OR_datagen_fn,
model_fn = calculate_costs_effects,
analysis_args = list(n_side_effects = n_side_effects,
n_patients = n_patients,
logor_side_effects_mu = logor_side_effects_mu,
logor_side_effects_sd = logor_side_effects_sd,
n.iter = 5000),
analysis_fn = OR_analysis_fn,
par_fn = generate_psa_parameters)
# Plot
EVPI <- evpi(chemotherapy_output)
plot(EVPI,
xlab = "Willingness-to-Pay",
ylab = "EVPI",
main = "Expected Value of Perfect Information",
type = "l")
points(chemotherapy_output$k, evsi_OR$evppi, type = "l", lty = 2)
x <- evsi_default %>% filter(n == 760) %>% select(evsi)
points(chemotherapy_output$k, evsi_OR$evsi, type = "l", lty = 3)
chemotherapy_output$k
evsi_OR$evsi
x <- evsi_OR %>% filter(n == 760) %>% select(evsi)
points(chemotherapy_output$k, x$evsi, type = "l", lty = 3)
######### Initial Simulation #################
library('boot')
library('dplyr')
library('INLA')
library('tidyverse')
inla.setOption(num.threads = 8)
setwd("C:/Users/Anna Heath/OneDrive/OneDrive - SickKids/Platform Trials/PRACTICAL Trial/IMV/DRIVE")
pdf_outcome1 <- readRDS(file = "VFDS_pdf.rds")
OR_mat <- matrix(c(0.8, 1, 1.1, 1.2, 1.25, 1.3, 1.5, rep(1, 6), 0.8, 1.1, 1.2, 1.25, 1.3, 1.5,
0.8, 1, 1.1, 1.2, 1.25, 1.3, 1.5, 0.8, 1.1, 1.2, 1.25, 1.3, 1.5, rep(1, 6)),
nrow = 19, ncol = 2)
TxARM_n <- c("DPL","UC")
N_sim = 1000
N_patient = 2000
burn.in <- 350
prob_sup = 0.995
prob_futi = 0.9
treat_futi <- "DPL"
states <- c("LSE", "HSE")
recruit_rate <- cbind(6 * 122, 6 * 68); colnames(recruit_rate) <- states
Result = array(dim = c(N_sim, 3, nrow(OR_mat), length(states)),
dimnames = list(c(),c("Sample.size", "TxARM", "Result"), c(), states))
pdf_outcome <- c()
for (i in 1:length(states)){
M <- as.data.frame(pdf_outcome1[,,i]) %>%
mutate(state = states[i])
pdf_outcome <- rbind(pdf_outcome ,M)
}
VFDs <- unique(pdf_outcome["VFDs"])
VFDs <- as.numeric(VFDs[,1])
k <- 19
OR_DPL = OR_mat[k, ]
p_UC_LSE <- as.numeric(pdf_outcome[pdf_outcome$state == 'LSE', "p_prob"])
p_UC_HSE <- as.numeric(pdf_outcome[pdf_outcome$state == 'HSE', "p_prob"])
p_DPL_LSE <- as.numeric(pdf_outcome[pdf_outcome$state == 'LSE', as.character(OR_DPL[1])])
p_DPL_HSE <- as.numeric(pdf_outcome[pdf_outcome$state == 'HSE', as.character(OR_DPL[2])])
i <- 120
there.has.been.an.error <- FALSE
set.seed(k * 10000 + i)
n_LSE <- recruit_rate[,"LSE"]
n_HSE <- recruit_rate[,"HSE"]
n_state <- cbind(n_LSE , n_HSE); colnames(n_state) <- states
np <- n <- num_patient <- sum(n_state)
TxARM <- factor(sample(TxARM_n , n, replace = TRUE))
State <- factor(sample(states , n, replace = TRUE, prob = c(n_LSE/n, n_HSE/n)))
n_state <- cbind(sum(State == "LSE"),
sum(State == "HSE")); colnames(n_state) <- states
outcome <- vector("numeric", length(TxARM))
outcome[TxARM == "UC" & State == "LSE"] <- sample(VFDs, sum(TxARM == "UC"& State == "LSE"), replace = TRUE, prob = p_UC_LSE)
outcome[TxARM == "UC" & State == "HSE"] <- sample(VFDs, sum(TxARM == "UC" & State == "HSE"), replace = TRUE, prob = p_UC_HSE)
outcome[TxARM == "DPL"& State == "LSE"] <- sample(VFDs, sum(TxARM == "DPL"& State == "LSE"), replace = TRUE, prob = p_DPL_LSE)
outcome[TxARM == "DPL"& State == "HSE"] <- sample(VFDs, sum(TxARM == "DPL"& State == "HSE"), replace = TRUE, prob = p_DPL_HSE)
sample_data <- data.frame(outcome, TxARM, State)
ref = "UC"
sample_data$TxARM = relevel(sample_data$TxARM, ref = ref)
ind <- matrix(0, 1, length(states)); colnames(ind) <- states
lc <- inla.make.lincombs(State = matrix(c(1,0, 0, 1), nrow = 2), TxARMDPL = c(1, 1), StateLSE = c(0, 0))
delta <- 1.2
v <- var(c(log(1), log(1.5)))
alpha <- ((2*2) / delta)^2 * 3 / 2 * v + 0 ## T
beta <- ((2 / 3 * (alpha + 1) * (delta / (2*2))^2) - v)
model <- inla(outcome ~ State + TxARM + f(State, TxARM, model = "iid",
hyper=list(theta=list(prior="loggamma",
param=c(alpha, beta))),# 0.125,0.00281
constr = TRUE),
data = sample_data,
lincomb = lc,
family = "pom",
verbose=FALSE, control.compute = list(config=TRUE),
control.family = list(hyper = list(theta1 = list(param = 100))))
model_no_borrow <- inla(outcome ~ State*TxARM,
data = sample_data,
lincomb = inla.make.lincombs(TxARMDPL = c(1, 1), 'StateLSE:TxARMDPL' = c(0, 1)),
family = "pom",
verbose=FALSE, control.compute = list(config=TRUE),
control.family = list(hyper = list(theta1 = list(param = 100))))
m0 <- model_no_borrow$marginals.lincomb.derived
marg_LSE <- m0$lc2
marg_HSE <- m0$lc1
Prob.differ.futi <- cbind("HSE" =inla.pmarginal(log(1.2), marg_HSE), "LSE" = inla.pmarginal(log(1.2), marg_LSE))
post.p_noborrow <- cbind("treat.opt" = TxARM_n,
"HSE" = c(1 - inla.pmarginal(log(1), marg_HSE), inla.pmarginal(log(1), marg_HSE)),
"LSE" = c(1 - inla.pmarginal(log(1), marg_LSE), inla.pmarginal(log(1), marg_LSE)))
m0 <- model$marginals.lincomb.derived
marg_LSE <- m0$lc2
marg_HSE <- m0$lc1
Prob.differ.futi <- cbind("HSE" =inla.pmarginal(log(1.2), marg_HSE), "LSE" = inla.pmarginal(log(1.2), marg_LSE))
post.p <- cbind("treat.opt" = TxARM_n,
"HSE" = c(1 - inla.pmarginal(log(1), marg_HSE), inla.pmarginal(log(1), marg_HSE)),
"LSE" = c(1 - inla.pmarginal(log(1), marg_LSE), inla.pmarginal(log(1), marg_LSE)))
post.p
summary(model)$lincomb.derived
post.p_noborrow
summary(model_no_borrow)$lincomb.derived
delta <- 2
v <- var(c(log(1), log(1.5)))
alpha <- ((2*2) / delta)^2 * 3 / 2 * v + 0 ## T
beta <- ((2 / 3 * (alpha + 1) * (delta / (2*2))^2) - v)
model <- inla(outcome ~ State + TxARM + f(State, TxARM, model = "iid",
hyper=list(theta=list(prior="loggamma",
param=c(alpha, beta))),# 0.125,0.00281
constr = TRUE),
data = sample_data,
lincomb = lc,
family = "pom",
verbose=FALSE, control.compute = list(config=TRUE),
control.family = list(hyper = list(theta1 = list(param = 100))))
model_no_borrow <- inla(outcome ~ State*TxARM,
data = sample_data,
lincomb = inla.make.lincombs(TxARMDPL = c(1, 1), 'StateLSE:TxARMDPL' = c(0, 1)),
family = "pom",
verbose=FALSE, control.compute = list(config=TRUE),
control.family = list(hyper = list(theta1 = list(param = 100))))
m0 <- model_no_borrow$marginals.lincomb.derived
marg_LSE <- m0$lc2
marg_HSE <- m0$lc1
Prob.differ.futi <- cbind("HSE" =inla.pmarginal(log(1.2), marg_HSE), "LSE" = inla.pmarginal(log(1.2), marg_LSE))
post.p_noborrow <- cbind("treat.opt" = TxARM_n,
"HSE" = c(1 - inla.pmarginal(log(1), marg_HSE), inla.pmarginal(log(1), marg_HSE)),
"LSE" = c(1 - inla.pmarginal(log(1), marg_LSE), inla.pmarginal(log(1), marg_LSE)))
m0 <- model$marginals.lincomb.derived
marg_LSE <- m0$lc2
marg_HSE <- m0$lc1
Prob.differ.futi <- cbind("HSE" =inla.pmarginal(log(1.2), marg_HSE), "LSE" = inla.pmarginal(log(1.2), marg_LSE))
post.p <- cbind("treat.opt" = TxARM_n,
"HSE" = c(1 - inla.pmarginal(log(1), marg_HSE), inla.pmarginal(log(1), marg_HSE)),
"LSE" = c(1 - inla.pmarginal(log(1), marg_LSE), inla.pmarginal(log(1), marg_LSE)))
post.p
summary(model)$lincomb.derived
post.p_noborrow
summary(model_no_borrow)$lincomb.derived
delta <- 10
v <- var(c(log(1), log(1.5)))
alpha <- ((2*2) / delta)^2 * 3 / 2 * v + 0 ## T
beta <- ((2 / 3 * (alpha + 1) * (delta / (2*2))^2) - v)
model <- inla(outcome ~ State + TxARM + f(State, TxARM, model = "iid",
hyper=list(theta=list(prior="loggamma",
param=c(alpha, beta))),# 0.125,0.00281
constr = TRUE),
data = sample_data,
lincomb = lc,
family = "pom",
verbose=FALSE, control.compute = list(config=TRUE),
control.family = list(hyper = list(theta1 = list(param = 100))))
model_no_borrow <- inla(outcome ~ State*TxARM,
data = sample_data,
lincomb = inla.make.lincombs(TxARMDPL = c(1, 1), 'StateLSE:TxARMDPL' = c(0, 1)),
family = "pom",
verbose=FALSE, control.compute = list(config=TRUE),
control.family = list(hyper = list(theta1 = list(param = 100))))
m0 <- model_no_borrow$marginals.lincomb.derived
marg_LSE <- m0$lc2
marg_HSE <- m0$lc1
Prob.differ.futi <- cbind("HSE" =inla.pmarginal(log(1.2), marg_HSE), "LSE" = inla.pmarginal(log(1.2), marg_LSE))
post.p_noborrow <- cbind("treat.opt" = TxARM_n,
"HSE" = c(1 - inla.pmarginal(log(1), marg_HSE), inla.pmarginal(log(1), marg_HSE)),
"LSE" = c(1 - inla.pmarginal(log(1), marg_LSE), inla.pmarginal(log(1), marg_LSE)))
m0 <- model$marginals.lincomb.derived
marg_LSE <- m0$lc2
marg_HSE <- m0$lc1
Prob.differ.futi <- cbind("HSE" =inla.pmarginal(log(1.2), marg_HSE), "LSE" = inla.pmarginal(log(1.2), marg_LSE))
post.p <- cbind("treat.opt" = TxARM_n,
"HSE" = c(1 - inla.pmarginal(log(1), marg_HSE), inla.pmarginal(log(1), marg_HSE)),
"LSE" = c(1 - inla.pmarginal(log(1), marg_LSE), inla.pmarginal(log(1), marg_LSE)))
post.p
summary(model)$lincomb.derived
post.p_noborrow
summary(model_no_borrow)$lincomb.derived
delta <- 0.3
v <- var(c(log(1), log(1.5)))
alpha <- ((2*2) / delta)^2 * 3 / 2 * v + 0 ## T
beta <- ((2 / 3 * (alpha + 1) * (delta / (2*2))^2) - v)
model <- inla(outcome ~ State + TxARM + f(State, TxARM, model = "iid",
hyper=list(theta=list(prior="loggamma",
param=c(alpha, beta))),# 0.125,0.00281
constr = TRUE),
data = sample_data,
lincomb = lc,
family = "pom",
verbose=FALSE, control.compute = list(config=TRUE),
control.family = list(hyper = list(theta1 = list(param = 100))))
model_no_borrow <- inla(outcome ~ State*TxARM,
data = sample_data,
lincomb = inla.make.lincombs(TxARMDPL = c(1, 1), 'StateLSE:TxARMDPL' = c(0, 1)),
family = "pom",
verbose=FALSE, control.compute = list(config=TRUE),
control.family = list(hyper = list(theta1 = list(param = 100))))
m0 <- model_no_borrow$marginals.lincomb.derived
marg_LSE <- m0$lc2
marg_HSE <- m0$lc1
Prob.differ.futi <- cbind("HSE" =inla.pmarginal(log(1.2), marg_HSE), "LSE" = inla.pmarginal(log(1.2), marg_LSE))
post.p_noborrow <- cbind("treat.opt" = TxARM_n,
"HSE" = c(1 - inla.pmarginal(log(1), marg_HSE), inla.pmarginal(log(1), marg_HSE)),
"LSE" = c(1 - inla.pmarginal(log(1), marg_LSE), inla.pmarginal(log(1), marg_LSE)))
m0 <- model$marginals.lincomb.derived
marg_LSE <- m0$lc2
marg_HSE <- m0$lc1
Prob.differ.futi <- cbind("HSE" =inla.pmarginal(log(1.2), marg_HSE), "LSE" = inla.pmarginal(log(1.2), marg_LSE))
post.p <- cbind("treat.opt" = TxARM_n,
"HSE" = c(1 - inla.pmarginal(log(1), marg_HSE), inla.pmarginal(log(1), marg_HSE)),
"LSE" = c(1 - inla.pmarginal(log(1), marg_LSE), inla.pmarginal(log(1), marg_LSE)))
post.p
summary(model)$lincomb.derived
post.p_noborrow
summary(model_no_borrow)$lincomb.derived
glm(n~N, family = "binomial", data = cbind(n = 7, N = 7))
glm(n~N, family = "binomial", data = data.frame(n = 7, N = 7))
library(INLA)
?inla.posterior.sample
?foreach
