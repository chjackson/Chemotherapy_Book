####################################################
## Calculating EVSI using Moment Matching Method  ##
## Using EVSI package                             ##
####################################################
# Load EVSI package
devtools::install_github("annaheath/EVSI")
library(EVSI)
library(BCEA)

# Number of Nested Simulations
Q <- 50

# Useful to set working directory to source file location.
# setwd()

## Run Initial PSA Results
source("PSA Distributions for Chemotherapy_JAGS.R")

# Run Decision model
source("Decision Model for Chemotherapy.R")

### Generate the future data
# Use gen.quantiles to find the parameter values used to generate the data
quants <- gen.quantiles(c("pi.1.","pi.2.",
                          "gamma.hosp","gamma.dead", 
                          "lambda.amb.rec.TH", "lambda.hosp.rec.TH"),
                        Chemotherapy_PSA, Q = Q, 
                        N = c(5, 1000))

# Initialise data list
data.list.full <- list()
for(i in 1:Q){
  # Number of patients with side effects
  X.SE1 <- rbinom(1, quants[i,"N"], quants[i,"pi.1."])
  X.SE2 <- rbinom(1, quants[i,"N"], quants[i,"pi.2."])
  
  # Number of patients hospitalised 
  X.N.hosp <- rbinom(1, sum(X.SE1,X.SE2), quants[i,"gamma.hosp"])
  # Number of patients who die
  X.N.dead <- rbinom(1, X.N.hosp, quants[i,"gamma.dead"])
  
  # Recovery time for patients
  N.amb <- sum(X.SE1,X.SE2) - X.N.hosp
  recover.amb <- -log(1 - quants[i,"lambda.amb.rec.TH"])
  T.rec.amb <- rexp(N.amb, recover.amb)
  N.hosp <- X.N.hosp - X.N.dead
  recover.hosp <- -log(1 - quants[i,"lambda.hosp.rec.TH"])
  T.rec.hosp <- rexp(N.hosp, recover.hosp)
  
  # Create a JAGS data list
  data.n <- list(X.SE1 = X.SE1, X.SE2 = X.SE2,
                 X.N.hosp = X.N.hosp, X.N.dead = X.N.dead,
                 N.amb = N.amb, T.rec.amb = T.rec.amb, 
                 N.hosp = N.hosp, T.rec.hosp = T.rec.hosp)
  
  # List the Q data lists
  data.list.full[[i]] <- data.n
}

### Bayesian model to update parameters from data
model.data.full<-function(){
  # Model for the proposed data collection
  X.SE1 ~ dbin(pi[1], n)
  X.SE2 ~ dbin(pi[2], n)
  X.N.hosp ~ dbinom(gamma.hosp, X.SE1+X.SE2)
  X.N.dead ~ dbin(gamma.dead, X.N.hosp)
  
  recover.amb <- -log(1-lambda.amb.rec.TH)
  recover.hosp <- -log(1-lambda.hosp.rec.TH)
  
  for(i in 1:N.amb){
    T.rec.amb[i] ~ dexp(recover.amb)
  }
  
  for(i in 1:N.hosp){
    T.rec.hosp[i] ~ dexp(recover.hosp)
  }
  
  # PSA distributions for the parameters
  num.se ~ dbin(pi[1], num.pat)    
  pi[1] ~ dbeta(1, 1)               
  
  rho ~ dnorm(m.rho, tau.rho)       
  pi[2] <- rho * pi[1]     
  
  for (t in 1:2) {
    SE[t] ~ dbin(pi[t], N)
  }
  
  num.hosp ~ dbin(gamma.hosp, num.se)    
  gamma.hosp ~ dbeta(1, 1)              
  
  num.dead ~ dbin(gamma.dead, num.se-num.hosp) 
  gamma.dead ~ dbeta(1, 4)                    
  
  lambda.amb.rec.TH ~ dbeta(p1.amb.rec, p2.amb.rec)
  lambda.hosp.rec.TH ~ dbeta(p1.hosp.rec, p2.hosp.rec)
  lambda.amb.amb <-(1-lambda.amb.rec.TH)*(1-lambda.amb.hosp)
  lambda.amb.rec<-(1-lambda.amb.hosp)*lambda.amb.rec.TH
  lambda.amb.hosp<-gamma.hosp/TH
  lambda.hosp.hosp<-(1-lambda.hosp.rec.TH)*(1-lambda.hosp.dead)
  lambda.hosp.rec<-(1-lambda.hosp.dead)*lambda.hosp.rec.TH
  lambda.hosp.dead<-gamma.dead/TH
  
  c.amb ~ dlnorm(m.amb, tau.amb)    
  c.hosp ~ dlnorm(m.hosp, tau.hosp)
  c.dead ~ dlnorm(m.dead, tau.dead) 
  
  e.chemo ~ dbeta(p1.chemo,p2.chemo)
  e.amb ~ dbeta(p1.amb,p2.amb)      
  e.hosp ~ dbeta(p1.hosp,p2.hosp)  
} 
R2OpenBUGS::write.model(model.data.full,"~/modelFilefull.txt")

## Initial PSA Analysis
mod<-bcea(e, c, ref = 2, interventions = c("Standard of Care", "New Treatment" ))
plot(mod)

## Load EVPPI calculation
load(file = "EVPPI_Results.RData")

## Calculate the Expected Posterior Variance
EVSI.var.full <- mm.post.var("~/modelFilefull.txt",data.list.full,
                             "n",quants[,"N"],
                             effects = effects, costs = costs,
                             he = mod, evi = evppi.calcs,
                             Q = 50, data.stats = data, 
                             update = "jags", n.iter = 500, n.burnin = 200)

# Calculate EVSI for a specific set of willingness-to-pay thresholds
EVSI.full <- evsi.calc(EVSI.var.full, wtp = seq(0, 50000, length.out = 101))

# Plot EVSI
plot(EVSI.full)

# Look at other plots
launch.App(EVSI.full)
